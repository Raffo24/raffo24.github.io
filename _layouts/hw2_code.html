<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Euler–Maruyama Simulation</title>
    <style>
        body {
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .container {
            background-color: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            text-align: center;
        }

        h1 {
            font-size: 24px;
            color: darkgreen;
        }

        h3 {
            font-weight: bold;
            font-family: verdana, sans-serif;
            color: darkgreen;
        }

        label {
            color: darkblue;
            font-weight: bold;
            text-align: left;
        }

        input, button {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        input[type="radio"] {
            width: auto;
            margin-right: 5px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        canvas {
            background-color: #1c1c1c;
            border: 1px solid grey;
            margin-top: 20px;
            display: block;
            margin: 20px auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Euler–Maruyama</h1>
        <div class="form-group">
            <label for="timesInput">Servers</label>
            <input type="number" id="timesInput" value="100" min="10" max="10000" step="10" class="form-control">
        </div>
        <div class="form-group">
            <label for="pathsInput">Hackers</label>
            <input type="number" id="pathsInput" value="50" min="10" max="10000" step="10" class="form-control">
        </div>
        <!--
        <div class="form-group">
            <label for="muInput">μ (drift):</label>
            <input type="number" id="muInput" value="0" min="-20" max="20" step=".1" class="form-control">
        </div>
        -->
        <!--
        <div class="form-group">
            <label for="sigmaInput">σ (diffusion):</label>
            <input type="number" id="sigmaInput" value="1" min="0.1" max="1000" step=".1" class="form-control">
        </div>
        -->
        <!--
        <div class="form-group">
            <label for="lambdaInput">λ</label>
            <input type="number" id="lambdaInput" value="50" min="1" max="1000" step="1" class="form-control">
        </div>
        -->
        <div class="form-group">
            <div class="form-check form-check-inline">
                <input type="radio" id="allAtOnce" name="animationGroup" class="form-check-input">
                <label for="allAtOnce" class="form-check-label">All at once</label>
            </div>
            <div class="form-check form-check-inline">
                <input type="radio" id="animated" name="animationGroup" checked class="form-check-input">
                <label for="animated" class="form-check-label">Slow animation</label>
            </div>
        </div>
        <hr>
        <canvas id="canvas" width="900" height="600" oncontextmenu="return false;" class="border"></canvas>
        <div class="form-group mt-3">
            <!--
            <div class="form-check">
                <input type="radio" id="bernulli" name="processGroup" class="form-check-input">
                <label for="bernulli" class="form-check-label">Bernulli [uses rate of occurrences λ]</label>
            </div>
            -->
            <div class="form-check">
                <input type="radio" id="randomWalk" name="processGroup" checked class="form-check-input">
                <label for="randomWalk" class="form-check-label">Random Walk (RW) [µ=0, uses σ] Absolute Frequency</label>
            </div>
            <div class="form-check">
                <input type="radio" id="relativeFrequency" name="processGroup" class="form-check-input">
                <label for="relativeFrequency" class="form-check-label">Relative Frequency {interval [-1,1]}</label>
            </div>
            <!--
            <div class="form-check">
                <input type="radio" id="poisson" name="processGroup" class="form-check-input">
                <label for="poisson" class="form-check-label">Poisson [uses rate of occurrences λ/N]</label>
            </div>
            -->
        </div>
        <button id="recomputeBtn" type="button" class="btn btn-primary mt-3">Generate new</button>
        <div style="text-align: center; margin-top: 20px;">
            <p><a href="/statistics/hw2" style="text-decoration: none; color: #337ab7;">Back to Theory</a></p>
        </div>
    </div>
    <script src="/assets/js/MyRndUtilities.js"></script>
    <script src="/assets/js/MyChartUtilities.js"></script>
    <script src="/assets/js/My2dUtilities.js"></script>
    <script src="/assets/js/MyDistributionUtilities.js"></script>
    <script src="/assets/js/Rettangolo.js"></script>
    <script>
        "use strict";

        document.addEventListener("DOMContentLoaded", function() {
            const VariateType = Object.freeze({
                RW: Symbol("randomWalk"),
                POISSON: Symbol("Poisson"),
                RELATIVE_FREQUENCY: Symbol("relativeFrequency"),
                BERNULLI: Symbol("bernoulli"),
            });

            const recomputeBtn = document.getElementById("recomputeBtn");
            const muInput = document.getElementById("muInput");
            const sigmaInput = document.getElementById("sigmaInput");
            const lambdaInput = document.getElementById("lambdaInput");
            const timesInput = document.getElementById("timesInput");
            const pathsInput = document.getElementById("pathsInput");

            const animated = document.getElementById("animated");

            const randomWalk = document.getElementById("randomWalk");
            //const poisson = document.getElementById("poisson");
            const relativeFrequency = document.getElementById("relativeFrequency");
            //const bernulli = document.getElementById("bernulli");

            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            let mu, sigma, lambda, n, numPaths, paths, randomJump, variate, scalingLimit, processType, processDesc, minView, maxView, range, intervalSize, numClasses, xOrigin, yOrigin, histTimeT, histTimeN, avgLast, ssLast, intervalsT, intervalsN, timer, animate, currentPath;

            const chartRect = new Rettangolo(20, 30, canvas.width - 200, canvas.height - 30 - 40);

            recomputeBtn.onclick = main;

            main();

            function main() {
                clearInterval(timer);
                getUserChoices();
                resetVariables();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                paths = [];

                if (animate) {
                    timer = setInterval(animatePaths, 10);
                } else {
                    for (let s = 1; s <= numPaths; s++) {
                        const newPath = createPath(s);
                        paths.push(newPath);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = MyChartUtilities.randomColorCSS();
                        ctx.stroke(newPath);
                    }
                    drawHistograms();
                    drawLegend();
                }
            }

            function getUserChoices() {
                mu = Number(muInput.value);
                sigma = Number(sigmaInput.value);
                lambda = Number(lambdaInput.value);
                n = Math.round(Number(timesInput.value));
                numPaths = Number(pathsInput.value);
                numClasses = Math.max(100, numPaths / 60);

                histTimeT = Math.round(n / 2);
                histTimeN = n;
                animate = animated.checked;

                const sigmaRange = 4;
/*
                if (randomWalk.checked) {
                    setProcess("Random Walk (sum of scaled Rademacher rv's = Σ σ R(-1,1), ±1 jumps, p=.5, mean=0, var = σ² t, std = σ √t", VariateType.RW, false, -sigmaRange * sigma * Math.sqrt(n), sigmaRange * sigma * Math.sqrt(n), () => MyRndUtilities.RademacherVariate(), (sum) => (sigma * sum));
                } else if (bernulli.checked) {
                    setProcess("Bernulli with rate λ ( ≈ Σ Be(λ), mean=λ, var=λ )", VariateType.BERNULLI, false, 0, lambda * 1.5, () => MyRndUtilities.bernoulliVariate(lambda/100), (sum) => (sum));
                } else if (relativeFrequency.checked) {
                    setProcess("Relative Frequency (f = rel freq = count/t ( Σ σ R(-1,1)), mean = p, var = √p(1-p)/t → 0)", VariateType.RELATIVE_FREQUENCY, false, -1, 1, () => (Math.random() <= lambda/100) ? -1 : 1, (sum,t) => (sum / t));
                }
                else if (poisson.checked) {
                    setProcess("Poisson with rate λ/N ( ≈ Σ Be(λ/N), mean=λ, var=λ )", VariateType.POISSON, false, 0, lambda * 1.5, () => MyRndUtilities.bernoulliVariate(lambda / n), (sum) => (sum));
                }
*/
                range = maxView - minView;
                intervalSize = range / numClasses;

                [xOrigin, yOrigin] = My2dUtilities.transformXYToViewport([0, 0], 0, n, minView, range, chartRect);
            }

            function setProcess(desc, type, scaling, min, max, jump, varFunc) {
                processDesc = desc;
                processType = type;
                scalingLimit = scaling;
                minView = min;
                maxView = max;
                randomJump = jump;
                variate = varFunc;
            }

            function resetVariables() {
                intervalsT = [];
                intervalsN = [];
                currentPath = 0;
                avgLast = 0;
                ssLast = 0;
            }

            function animatePaths() {
                const newPath = createPath(paths.length + 1);
                paths.push(newPath);
                redraw(true);

                if (paths.length >= numPaths) {
                    clearInterval(timer);
                    redraw(false);
                }
            }

            function createPath(s) {
                currentPath = s;
                const path = new Path2D();

                let sum = 0; 
                let prevY = yOrigin;

                path.moveTo(xOrigin, yOrigin);

                for (let t = 1; t <= n; t++) {
                    sum += randomJump();
                    let value = variate(sum, t);

                    console.log("t = " + t + "  sum = " + sum + "  value = " + value);
                    if (t === histTimeT) {
                        MyDistributionUtilities.allocateValueInIntervals(value, intervalsT, intervalSize);
                    } else if (t === histTimeN) {
                        MyDistributionUtilities.allocateValueInIntervals(value, intervalsN, intervalSize);
                        [avgLast, ssLast] = MyDistributionUtilities.UpdateMeanAndSS(value, s, [avgLast, ssLast]);
                    }

                    const x = My2dUtilities.transformX(t / n, 0, 1, chartRect.x, chartRect.width);
                    const y = My2dUtilities.transformY(value, minView, range, chartRect.y, chartRect.height);

                    path.lineTo(x, prevY);
                    prevY = y;
                    path.lineTo(x, y);
                }

                return path;
            }

            function redraw(allGray) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (const p of paths) {
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = allGray ? MyChartUtilities.randomRgbaString(0.2) : MyChartUtilities.randomColorCSS();
                    ctx.stroke(p);
                }
                if (allGray) {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "red";
                    ctx.stroke(paths[paths.length - 1]);
                }

                drawHistograms();
                drawLegend();
            }

            function drawHistograms() {
                const histRectT = new Rettangolo(My2dUtilities.transformX(histTimeT, 0, n, chartRect.x, chartRect.width), chartRect.y, 150, chartRect.height);
                const histRectN = new Rettangolo(My2dUtilities.transformX(histTimeN, 0, n, chartRect.x, chartRect.width), chartRect.y, 150, chartRect.height);
                histRectT.disegnaRettangolo(ctx, "rgba(100,100,250,0.5)", 2, [1, 1]);
                histRectN.disegnaRettangolo(ctx, "rgba(250,100,150,0.5)", 2, [1, 1]);

                MyChartUtilities.verticalHistoFromIntervals(ctx, intervalsT, minView, maxView - minView, histRectT, "red", 1, "red");
                MyChartUtilities.verticalHistoFromIntervals(ctx, intervalsN, minView, maxView - minView, histRectN, "green", 1, "lightgreen");
            }

            function drawLegend() {
                chartRect.disegnaRettangolo(ctx, "darkblue", 2, []);

                ctx.font = "11px Verdana";
                ctx.fillStyle = "white";
                ctx.fillText(maxView.toFixed(1), chartRect.right() + 10, chartRect.y - 7);
                ctx.fillText(minView.toFixed(1), chartRect.right() + 10, chartRect.bottom() - 7);
                ctx.fillStyle = "lightblue";
                ctx.fillText("paths: " + currentPath + "  avg = " + avgLast.toFixed(2) + "  var = " + (ssLast / numPaths).toFixed(2), chartRect.x + 350, chartRect.bottom() + 30);
                ctx.fillStyle = "white";
                ctx.fillText(processDesc, chartRect.x + 100, chartRect.y + 15);

                ctx.beginPath();

                if (scalingLimit) {
                    ctx.fillStyle = "orange";
                    ctx.strokeStyle = "orange";
                    for (let t = 0; t <= 1; t += 0.1) {
                        let x = My2dUtilities.transformX(t, 0, 1, chartRect.x, chartRect.width);
                        ctx.moveTo(x, chartRect.bottom() - 3);
                        ctx.lineTo(x, chartRect.bottom() + 3);
                        ctx.fillText(t.toFixed(1).toString(), x - 5, chartRect.bottom() + 15);
                    }
                }

                ctx.stroke();
            }

            window.onload = main;
        });
    </script>
</body>

</html>